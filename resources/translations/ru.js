// eslint-disable-next-line no-undef
module.exports = {
    "DataStructures": {
        "Title": "Структуры данных",
        "Array": {
            "Title": "Массив (Array)",
            "Term": "    Массив - это структура данных, хранящая набор значений (элементов массива), идентифицируемых с помощью одного или нескольких индексов. Доступ к каждому из элементов массива осуществляется по индексу этого элемента. Индекс - это число, которое означает положение элемента в массиве.",
            "Types": "Типы массивов\n",
            "TypeStatic": {
                "Title": "Статический\n",
                "Term": "    Обычные массивы называют статическими (фиксированными). Массив является статическим, потому что мы задаем конкретный размер массива при написании кода программы и он не меняется во время исполнения\n"
            },
            "TypeDynamic": {
                "Title": "Динамический\n",
                "Term": "    Динамическим называется массив, размер которого может изменяться во время исполнения программы. Динамические массивы дают возможность более гибкой работы с данными, так как позволяют не прогнозировать хранимые объёмы данных, а регулировать размер массива в соответствии с реально необходимыми объёмами.\n"
            },
            "TypeHeterogeneous": {
                "Title": "Гетерогенный\n",
                "Term": "    Гетерогенным называется массив, в разные элементы которого могут быть непосредственно записаны значения, относящиеся к различным типам данных.\n"
            },
            "Memory": {
                "Title": "Память",
                "Term": "    Данные хранятся в памяти последовательно (один за другим). Из этого следует то, что адрес каждого элемента массива может быть вычислен с помощью индекса. Это позволяет организовать произвольный доступ к данным."
            },
            "Features": {
                "Title": "Особенности",
                "Feature_1": "● Одинаковое время доступа ко всем элементам массива\n",
                "Feature_2": "● Невозможность удаления или добавления элемента без сдвига других элементов массива\n",
                "Feature_3": "● Легко вычислить адрес элемента по его индексу, поскольку элементы распологаются одни за другим\n"
            }
        },
        "Queue": {
            "Title": "Очередь (Queue)",
            "Term": "    Очередь - это струтура данных, в которой данные хранятся по принципу: \"Первый вошел - первый вышел\" (FIFO - first in first out). Исходя из определения мы не можем получить доступ к произвольному элементу очереди. У очереди существует голова (head) и хвост (tail). Когда элемента доабвляется (enqueue) в очередь, он занимает место в ее хвосте, выборка (dequeue) же элемента осуществляется из начала (головы) очереди, при этом выбранный элементы из очереди удаляется."
        },
        "Stack": {
            "Title": "Стек (Stack)",
            "Term": "    Стек - это структура данных, в которой данные хранятся по принципу: \"Последним пришел - первым вышел\" (LIFO - last in first out). Одна из возможных реализациий стека - это реализация в виде однонправленного списка. При такой реализации каждый элеменет в списке содержит помимо хранимой информации в стеке указатель на следующий элемент стека. Стоит отметить, что занчение переменной стека, явлется указателем на его вершину, то есть хранит адрес вершины.",
            "Operations": {
                "Title": "Операции со стеком",
                "Push": "● push - добваление элемента в стек. Новый элемент будет иметь указатель на предыдущий элемент, бывший до этого головой (head).\n",
                "Pop": "● pop - удаление элемента из стека.\n",
                "Peek": "● peek - возвращается элемент с головы (head) без его удаления.\n"
            }
        },
        "Set": {
            "Title": "Множество (Set)",
            "Term": "   Множество - это структура данных, которая является реализацией математического объекта множество. Множество содержит конечный набор элементов некоторого типа, без опредленного порядка. Каждый элемент содержится только в одном экземпляре. В множество M можно добавить элемент x, из множества M можно удалить элемент x. Если при операциях удаления и добавления элемента в множество элемент уже существует или его нет, то ничего не происходит. Так же для заданного элемента x из множества M можно определить содержится ли элемент в множестве."
        },
        "Map": {
            "Title": "Карта (Map)",
            "Term": "   Карта - это структура данных, которая хранит данные в виде пар ключ -> значение, где каждый ключ является уникальным. В паре (key, value) значение value называется значением, ассоциированным с ключом key, поэтому иногда можно встерить другие названия данной струкутры данных, а именно: Ассоциативный массив (Associative array) или Словарь (Dictionary).",
            "Operations": {
                "Title": "Операции\n",
                "Add": "● Добвление пары (key, value) в коллекцию\n",
                "Remove": "● Удаление пары  (key, value) в коллекцию\n",
                "Change": "● Изменение существующей пары (key, value) в колекции\n",
                "Find": "● Поиск значения (value), связанного с оперделенным ключом (key)\n"
            }
        },
        "HashTables": {
            "Title": "Хэш-таблица (Hash-table)",
            "Term": "    Хэш-таблица - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (key, value) и выполнять оперицаии добавления, удаления и поиска. В данной сткрутуре даных используется хэш-функция для вычисления индекса в массиве, по которому можно найти желаемое значение. Другими словами ключ (key) проходит через хэш-функцию и превращается в число. Это числовое значение затем используется в качестве фактического ключа, в котором хранится значение (value). Главное свойство хэш-таблиц - все три вышеописанные  операции выполняются за время O(1).",
            "CollisionResolve": {
                "Title": "Борьба с коллизиями\n",
                "Intro": "    В идеальном случае, когда заранее известны все пары (key, value), достаточно легко реализовать хеш-таблицу, в которой время поиска будет постоянным. Но в большинестве случаев приходится бороться с коллизиями. Коллизия - это когда два ввода, поступающие на вход хэш-функции хэшируются с одним и тем же цифровым выходом. Наиболее популярные методы для борьбы с коллизиями - это методы открытой индексации и цепочек"
            }
        },
        "LinkedList": {
            "Title": "Связные списки (Linked lists)",
            "Term": "    Связный список - это сткруктура данных, которая состоит из ячеек, каждая из которых содержит как собственные данные, так и указатель на следующую ячейку списка.",
            "Picture": "На рисунке выше показаны два связных списка, в которых сожержатся цифры 31, 72, 47, 9. Верхняя переменная top - это указатель на первую ячейку списка, а нижняя - первая ячейка в спсике. Оба списка заканчиваются квадратиком с косым перекрестием - так обозначается нулвеой указатель.",
            "TypesOfLinkedLists": {
                "Title": "Виды связных списков\n\n",
                "UnidirectionalLinkedList": {
                    "Title": "Однонаправленный связный список\n\n",
                    "Info": "    Данный тип связного списка состоит из элементов, связанных между собой последовательно посредством указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на null. Элемент, на котороый нет указателя, является головным (head) элементом списка. В односвязном списке можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.\n\n"
                },
                "BidirectionalLinkedList": {
                    "Title": "Двунаправленный связный список\n\n",
                    "Info": "    Как и односвязный список, двусвязный допускает только последовательный доступ к элементам, но при этом дает возможность перемещения в обе стороны. Другими словами в данном типе связного списка указатели в каждом элементе указывают на предыдущий и на последующий элемент в списке.\n\n"
                },
                "RingLinkedList": {
                    "Title": "Кольцевой связный список\n\n",
                    "Info": "    В данном виде связного списка последний элемент указывает на первый элемент списка, а первый (в случае двусвязного списка) — на последний. В этом списке ссылки на NULL не встречается."
                }
            }
        }
    },
    "Algorithms": {
        "Title": "Алгоритмы"
    }
};
